<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/previews/PR25/libs/katex/katex.min.css"> <link rel=stylesheet  href="/previews/PR25/libs/highlight/github.min.css"> <link rel=stylesheet  href="/previews/PR25/css/franklin.css"> <link rel=stylesheet  href="/previews/PR25/css/poole_hyde.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/previews/PR25/assets/favicon.png"> <title>Creating a JSO-compliant solver</title> <link rel=stylesheet  href="/previews/PR25/css/custom.css"> <link rel=preconnect  href="https://fonts.gstatic.com"> <link href="https://fonts.googleapis.com/css2?family=Nunito&family=Montserrat&display=swap" rel=stylesheet > <script src="/previews/PR25/libs/highlight/highlight.pack.js"></script> <!--TODO: Add EVERYTHING-->> <script> hljs.getLanguage('julia').keywords.custom = 'obj grad hess AbstractNLPModel'; </script>" <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <img src="/previews/PR25/assets/jso.png"> <h1><a href="/previews/PR25/">JSO</a></h1> <p class=lead >Julia Smooth Optimizers.</p> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/previews/PR25/">Home</a> <a class="sidebar-nav-item subitem" href="/previews/PR25/index.html#documentation_resources">Doc resources</a> <a class="sidebar-nav-item subitem" href="/previews/PR25/index.html#publications_talks_and_other_references">References</a> <a class="sidebar-nav-item " href="/previews/PR25/pages/tutorials/list/">Tutorials</a> <a class="sidebar-nav-item " href="/previews/PR25/pages/ecosystem/list/">Ecosystems</a> <a class="sidebar-nav-item subitem " href="/previews/PR25/pages/ecosystem/linear-algebra/">Linear Algebra</a> <a class="sidebar-nav-item subitem " href="/previews/PR25/pages/ecosystem/models/">Models</a> <a class="sidebar-nav-item subitem " href="/previews/PR25/pages/ecosystem/solvers/">Solvers</a> <a class="sidebar-nav-item " href="/previews/PR25/pages/how-to/list/">How-to guide</a> <a class="sidebar-nav-item " href="/previews/PR25/pages/reference/list/">Reference guides</a> </nav> <p>&copy; Abel Soares Siqueira.</p> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id=title ><a href="#title" class=header-anchor >Creating a JSO-compliant solver</a></h1></p> <div class=author >by Abel S. Siqueira and João Okimoto</div> <p><img class=badge  src="https://img.shields.io/badge/ADNLPModels-0.3.0-hsl(36,100%25,30%25)?style=flat-square&labelColor=hsl(36,30%25,30%25)"> <img class=badge  src="https://img.shields.io/badge/JSOSolvers-0.7.2-hsl(72,100%25,30%25)?style=flat-square&labelColor=hsl(72,30%25,30%25)"> <img class=badge  src="https://img.shields.io/badge/LinearAlgebra-STDLIB-666?style=flat-square&labelColor=444"> <img class=badge  src="https://img.shields.io/badge/NLPModels-0.17.2-hsl(180,100%25,30%25)?style=flat-square&labelColor=hsl(180,30%25,30%25)"> <img class=badge  src="https://img.shields.io/badge/Plots-1.25.0-666?style=flat-square&labelColor=999"> <img class=badge  src="https://img.shields.io/badge/SolverBenchmark-0.4.7-hsl(288,100%25,30%25)?style=flat-square&labelColor=hsl(288,30%25,30%25)"> <img class=badge  src="https://img.shields.io/badge/SolverCore-0.2.1-hsl(324,100%25,30%25)?style=flat-square&labelColor=hsl(324,30%25,30%25)"> <p>In this tutorial you will learn what is a JSO-compliant solver, how to create one, and how to benchmark it against some other solver.</p> <div class=franklin-toc ><ol><li><a href="#what_is_a_jso-compliant_solver">What is a JSO-compliant solver</a><li><a href="#method_description">Method description</a><li><a href="#defining_a_test_problem_with_adnlpmodels_and_accessing_its_functions_with_the_nlpmodels_api">Defining a test problem with ADNLPModels and accessing its functions with the NLPModels API</a><li><a href="#improving_the_solver">Improving the solver</a><li><a href="#benchmarking">Benchmarking</a><li><a href="#performance_profiles">Performance profiles</a><li><a href="#improving_the_solver_more">Improving the solver more</a></ol></div> <h2 id=what_is_a_jso-compliant_solver ><a href="#what_is_a_jso-compliant_solver" class=header-anchor >What is a JSO-compliant solver</a></h2> <p>A JSO-compliant solver is a solver whose</p> <ul> <li><p>input is a model implementing the NLPModels API; and</p> <li><p>output is a specific struct from the package SolverCore.</p> </ul> <p>That means that you can devise your solver based on a single API that will work with many different problems. Furthermore, since the output type is known, we can provide tools to compare different solvers.</p> <p>To illustrate the procedure for creating a solver with the JSO API, we&#39;ll implement a Line-Search Modified Newton solver for the problem</p> \[ \min_x \ f(x) \] <h2 id=method_description ><a href="#method_description" class=header-anchor >Method description</a></h2> <p>The method consists of following the direction \(d_k\) that solves</p> \[ \nabla^2 f(x_k) d_k = -\nabla f(x_k) \] <p>This is only reasonable if the system can be solved and \(d_k\) is a descent direction. A sufficient condition for that is that \(\nabla^2 f(x_k)\) is positive definite, which is equivalent to saying that it has a Cholesky decomposition.</p> <p>Since this will not be true in general, the modified Newton method consists of computing \(\rho_k \geq 0\) such that \(\nabla^2 f(x_k) + \rho_k I\) is positive definite. One way to find such a \(\rho_k\) is given below</p> <pre><code class=language-julia >1. Start with ρ from the last iteration
2. Try to compute the Cholesky factor of ∇²f&#40;x&#41; &#43; ρI
3. If not successful, increase ρ to either 1e-8 or 10ρ, whichever is largest, and return to step 2
4. Otherwise, continue the algorithm</code></pre> <p>Next, for the line-search part, we use backtracking and ask that the Armijo condition be satisfied, that is find the smallest \(p \in \mathbb{N}\) such that \(t = σ^p\) satisfies</p> \[ f(x_k + td_k) < f(x_k) + \alpha t g_k^T d_k, \] <p>for \(\alpha \in (0,1)\), called the Armijo parameter.</p> <h2 id=defining_a_test_problem_with_adnlpmodels_and_accessing_its_functions_with_the_nlpmodels_api ><a href="#defining_a_test_problem_with_adnlpmodels_and_accessing_its_functions_with_the_nlpmodels_api" class=header-anchor >Defining a test problem with ADNLPModels and accessing its functions with the NLPModels API</a></h2> <p>Let&#39;s define a test problem to verify that our method is working, and let&#39;s use a classic one: Rosenbrock&#39;s function<sup id="fnref:1"><a href="#fndef:1" class=fnref >[1]</a></sup></p> \[ \min_x \ (x_1 - 1)^2 + 4 (x_2 - x_1^2)^2, \] <p>starting from point &#91;-1.2; 1.0&#93;.</p> <pre><code class=language-julia >using Plots
gr&#40;size&#61;&#40;600,300&#41;&#41;
contour&#40;-2:0.02:2, -0.5:0.02:1.5, &#40;x,y&#41; -&gt; &#40;x - 1&#41;^2 &#43; 4 * &#40;y - x^2&#41;^2, levels&#61;&#40;0:0.2:10&#41;.^2&#41;</code></pre> <img src="/previews/PR25/assets/pages/tutorials/creating-a-jso-compliant-solver/code/output/prob1.png" alt="Contour plot of objective"> <p>Notice that the solution of the problem, i.e., the point at which the function is minimum, is \(x = (1,1)^T\). This can be estimated by the plot and verified by noticing that \(f(1,1) = 0\) and \(f(x) > 0\) for any other point.</p> <p>To write this problem as a NLPModel, we have a few options, but for now let&#39;s consider the simplest one: ADNLPModels. ADNLPModels has a simple interface and it computes the derivatives using automatic differentiation from other packages.</p> <pre><code class=language-julia >using ADNLPModels

nlp &#61; ADNLPModel&#40;
  x -&gt; &#40;x&#91;1&#93; - 1&#41;^2 &#43; 4 * &#40;x&#91;2&#93; - x&#91;1&#93;^2&#41;^2, # function
  &#91;-1.2; 1.0&#93; # starting point
&#41;</code></pre><pre><code class="plaintext code-output">ADNLPModel - Model with automatic differentiation backend ADNLPModels.ForwardDiffAD(3, 0)
  Problem name: Generic
   All variables: ████████████████████ 2      All constraints: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
            free: ████████████████████ 2                 free: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
           lower: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                lower: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
           upper: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                upper: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
         low/upp: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0              low/upp: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
           fixed: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                fixed: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
          infeas: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0               infeas: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
            nnzh: (  0.00% sparsity)   3               linear: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
                                                    nonlinear: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
                                                         nnzj: (------% sparsity)         

  Counters:
             obj: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                 grad: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                 cons: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
            jcon: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                jgrad: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                  jac: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
           jprod: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0               jtprod: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                 hess: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
           hprod: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0                jhess: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0               jhprod: ⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅⋅ 0     
</code></pre> <p>Now we access the information of the model, and its functions. The information is all stored on <code>nlp.meta</code>, while the functions are defined by NLPModels.</p> <p>The main information you may want is summarised below</p> <pre><code class=language-julia >&#40;
  nlp.meta.nvar, # number of variable
  nlp.meta.ncon, # number of constraints
  nlp.meta.lvar, nlp.meta.uvar, # bounds on variables
  nlp.meta.lcon, nlp.meta.ucon, # bounds on constraints
  nlp.meta.x0 # starting point
&#41;</code></pre><pre><code class="plaintext code-output">(2, 0, [-Inf, -Inf], [Inf, Inf], Float64[], Float64[], [-1.2, 1.0])</code></pre>
<p>Furthermore, you can use some functions from NLPModels to query whether the problem has bounds, equalities, inequalities, etc.</p>
<pre><code class=language-julia >using NLPModels

unconstrained&#40;nlp&#41;</code></pre><pre><code class="plaintext code-output">true</code></pre>
<p>Finally, we can access the objective function, its gradients and Hessian with</p>
<pre><code class=language-julia >x &#61; nlp.meta.x0
obj&#40;nlp, x&#41;</code></pre><pre><code class="plaintext code-output">5.614400000000001</code></pre>
<pre><code class=language-julia >grad&#40;nlp, x&#41;</code></pre><pre><code class="plaintext code-output">2-element Vector{Float64}:
 -12.847999999999999
  -3.5199999999999996</code></pre>
<pre><code class=language-julia >hess&#40;nlp, x&#41;</code></pre><pre><code class="plaintext code-output">2×2 LinearAlgebra.Symmetric{Float64, Matrix{Float64}}:
 55.12  19.2
 19.2    8.0</code></pre>
<p>For our basic unconstrained solver that&#39;s enough. If you want more functions, check the <a href="/previews/PR25/pages/references/NLPModels/">NLPModels reference guide</a>.</p>
<p>Notice that the Hessian returned from <code>hess</code> has only the lower triangle. That&#39;s done, in general, to avoid storing repeated elements. In this dense case, this isn&#39;t much helpful, so we can simply use <code>Symmetric</code> to fill the rest.</p>
<pre><code class=language-julia >using LinearAlgebra

Symmetric&#40;hess&#40;nlp, x&#41;, :L&#41;</code></pre><pre><code class="plaintext code-output">2×2 LinearAlgebra.Symmetric{Float64, Matrix{Float64}}:
 55.12  19.2
 19.2    8.0</code></pre>
<p>To compute Cholesky and verify that it succeeds, we use <code>cholesky</code> and <code>issuccess</code>.</p>
<pre><code class=language-julia >B &#61; Symmetric&#40;hess&#40;nlp, x&#41;, :L&#41;
factor &#61; cholesky&#40;B, check&#61;false&#41; # check is false to prevent an error from being thrown.
issuccess&#40;factor&#41;</code></pre><pre><code class="plaintext code-output">true</code></pre>
<pre><code class=language-julia >B &#61; -Symmetric&#40;hess&#40;nlp, x&#41;, :L&#41; # Since the last one is positive definite, this one shouldn&#39;t be
factor &#61; cholesky&#40;B, check&#61;false&#41;
issuccess&#40;factor&#41;</code></pre><pre><code class="plaintext code-output">false</code></pre>
<p>Therefore the direction computation can be done as</p>
<pre><code class=language-julia >ρ &#61; 0.0 # First iteration

B &#61; Symmetric&#40;hess&#40;nlp, x&#41;, :L&#41;
factor &#61; cholesky&#40;B &#43; ρ * I, check&#61;false&#41;
while &#33;issuccess&#40;factor&#41;
  ρ &#61; max&#40;1e-8, 10ρ&#41;
  factor &#61; cholesky&#40;B &#43; ρ * I, check&#61;false&#41;
end
d &#61; factor \ -grad&#40;nlp, x&#41;</code></pre><pre><code class="plaintext code-output">2-element Vector{Float64}:
  0.4867256637168144
 -0.7281415929203545</code></pre>
<p>The second part of our method is the step length computation. Let&#39;s use <code>α &#61; 1e-2</code> for our Armijo parameter.</p>
<pre><code class=language-julia >α &#61; 1e-2
t &#61; 1.0
fx &#61; obj&#40;nlp, x&#41;
ft &#61; obj&#40;nlp, x &#43; t * d&#41;
slope &#61; dot&#40;grad&#40;nlp, x&#41;, d&#41;
while &#33;&#40;ft ≤ fx &#43; t * slope&#41;
  global t *&#61; 0.5 # global is used because we are outside a function
  ft &#61; obj&#40;nlp, x &#43; t * d&#41;
end</code></pre>
<p>The two snippets above are what define our method. We&#39;ll use the first order criteria for stopping the algorithm, that is</p>
\[ \| \nabla f(x_k) \| < \epsilon \]
<pre><code class=language-julia >using SolverCore

function newton&#40;nlp :: AbstractNLPModel&#41;

  x &#61; copy&#40;nlp.meta.x0&#41; # starting point
  α &#61; 1e-2 # Armijo parameter
  ρ &#61; 0.0

  while norm&#40;grad&#40;nlp, x&#41;&#41; &gt; 1e-6

    # Computing the direction
    B &#61; Symmetric&#40;hess&#40;nlp, x&#41;, :L&#41;
    factor &#61; cholesky&#40;B &#43; ρ * I, check&#61;false&#41;
    while &#33;issuccess&#40;factor&#41;
      ρ &#61; max&#40;1e-8, 10ρ&#41;
      factor &#61; cholesky&#40;B &#43; ρ * I, check&#61;false&#41;
    end
    d &#61; factor \ -grad&#40;nlp, x&#41;

    # Computing the step length
    t &#61; 1.0
    fx &#61; obj&#40;nlp, x&#41;
    ft &#61; obj&#40;nlp, x &#43; t * d&#41;
    slope &#61; dot&#40;grad&#40;nlp, x&#41;, d&#41;
    while &#33;&#40;ft ≤ fx &#43; α * t * slope&#41;
      t *&#61; 0.5
      ft &#61; obj&#40;nlp, x &#43; t * d&#41;
    end

    x &#43;&#61; t * d
  end

  status &#61; :first_order

  return GenericExecutionStats&#40;status, nlp&#41;

end</code></pre><pre><code class="plaintext code-output">newton (generic function with 1 method)</code></pre>
<p>Notice the two conditions for the method to be JSO-compliant:</p>
<ul>
<li><p>Input is a NLPModel - Namely, an <code>AbstractNLPModel</code>:</p>

</ul>
<pre><code class=language-julia >function newton&#40;nlp :: AbstractNLPModel&#41;</code></pre>
<ul>
<li><p>output is a specific struct from the package SolverCore - Namely, a <code>GenericExecutionStats</code>:</p>

</ul>
<pre><code class=language-julia >return GenericExecutionStats&#40;status, nlp&#41;</code></pre>
<p>For this structure to be used, a <code>status</code> argument needs to be passed, indicating what&#39;s the situation of the solver run. We passed a <code>:first_order</code> value, indicating that a first order solution was found. More about this later.</p>
<p>The NLPModels API provides you with the derivatives, and anything else can reside inside the function, and there is where the magic happens.</p>
<p>Let&#39;s run our implementation on the problem we defined before.</p>
<pre><code class=language-julia >output &#61; newton&#40;nlp&#41;

println&#40;output&#41;</code></pre><pre><code class="plaintext code-output">Generic Execution stats
  status: first-order stationary
  objective value: Inf
  primal feasibility: 0.0
  dual feasibility: Inf
  solution: ∅
  iterations: -1
  elapsed time: Inf
</code></pre>
<p>The <code>GenericExecutionStats</code> structure holds all relevant information. Notice, however, that it doesn&#39;t have anything useful in this case. Naturally, we have to return that information as well.</p>
<p>Update your <code>newton</code> function so that the end is something like the following.</p>
<pre><code class=language-julia >function newton&#40;nlp :: AbstractNLPModel&#41;
  # …

  return GenericExecutionStats&#40;status, nlp, solution&#61;x, objective&#61;obj&#40;nlp, x&#41;&#41;
end</code></pre><pre><code class="plaintext code-output">newton (generic function with 1 method)</code></pre>
<p>Now run again</p>
<pre><code class=language-julia >output &#61; newton&#40;nlp&#41;

println&#40;output&#41;</code></pre><pre><code class="plaintext code-output">Generic Execution stats
  status: first-order stationary
  objective value: 7.141610295610004e-18
  primal feasibility: 0.0
  dual feasibility: Inf
  solution: [0.9999999973418803  0.9999999945459112]
  iterations: -1
  elapsed time: Inf
</code></pre>
<p>That&#39;s already better. Now we can access the solution with</p>
<pre><code class=language-julia >output.solution</code></pre><pre><code class="plaintext code-output">2-element Vector{Float64}:
 0.9999999973418803
 0.9999999945459112</code></pre>
<h2 id=improving_the_solver ><a href="#improving_the_solver" class=header-anchor >Improving the solver</a></h2>
<p>Although we have an implementation of our method, it has a few shortcomings, which we must address before continuing. Mainly, our solver needs a better handling of the stopping conditions. Currently, we only stop when the first order condition \(\|\nabla f(x_k)\| < \epsilon\) is satisfied. Although our method is good, this could fail to happen in a reasonable time, and therefore we have to define some stopping conditions to prevent an infinite loop.</p>
<p>The two main conditions we&#39;ll add are the number of iterations and elapsed time to be limited. In this case, the result of the solver run may no be a <code>:first_order</code> situation anymore, which means that we need to use other <code>status</code> value. Here&#39;s the list:</p>
<pre><code class=language-julia >SolverCore.show_statuses&#40;&#41;</code></pre><pre><code class="plaintext code-output">STATUSES:
  :acceptable     => solved to within acceptable tolerances
  :exception      => unhandled exception
  :first_order    => first-order stationary
  :infeasible     => problem may be infeasible
  :max_eval       => maximum number of function evaluations
  :max_iter       => maximum iteration
  :max_time       => maximum elapsed time
  :neg_pred       => negative predicted reduction
  :not_desc       => not a descent direction
  :small_residual => small residual
  :small_step     => step too small
  :stalled        => stalled
  :unbounded      => objective function may be unbounded from below
  :unknown        => unknown
  :user           => user-requested stop
</code></pre>
<p>We can see that <code>max_iter</code> and <code>max_time</code> are the most adequates for our case.</p>
<p>In addition, the maximum amount of time and iterations that the solver can execute are usually arguments passed to the solver. Since the only mandatory argument must be the model, we can use optional arguments. We prefer to use keywords.</p>
<p>Change your code considering the changes below:</p>
<pre><code class=language-julia >function newton&#40;
  nlp :: AbstractNLPModel; # Only mandatory argument, notice the ;
  max_time :: Float64 &#61; 30.0, # maximum allowed time
  max_iter :: Int &#61; 100 # maximum allowed iterations
&#41;
  # …
  iter &#61; 0
  t₀ &#61; time&#40;&#41;
  Δt &#61; time&#40;&#41; - t₀
  status &#61; :unknown
  tired &#61; Δt ≥ max_time &gt; 0 || iter ≥ max_iter &gt; 0
  solved &#61; norm&#40;grad&#40;nlp, x&#41;&#41; ≤ 1e-6
  while &#33;&#40;solved || tired&#41;
    # …
    iter &#43;&#61; 1
    Δt &#61; time&#40;&#41; - t₀
    tired &#61; Δt ≥ max_time &gt; 0 || iter ≥ max_iter &gt; 0
    solved &#61; norm&#40;grad&#40;nlp, x&#41;&#41; ≤ 1e-6
  end
  if solved
    status &#61; :first_order
  elseif tired
    if Δt ≥ max_time &gt; 0
      status &#61; :max_time
    elseif iter ≥ max_iter &gt; 0
      status &#61; :max_iter
    end
  end

  return GenericExecutionStats&#40;status, nlp, solution&#61;x, objective&#61;obj&#40;nlp, x&#41;, iter&#61;iter, elapsed_time&#61;Δt&#41;
end</code></pre><pre><code class="plaintext code-output">newton (generic function with 1 method)</code></pre>
<p>Many of the lines are self-explanatory, so let&#39;s focus on the complex ones.</p>
<pre><code class=language-julia >tired &#61; Δt ≥ max_time &gt; 0 || iter ≥ max_iter &gt; 0
solved &#61; norm&#40;grad&#40;nlp, x&#41;&#41; ≤ 1e-6
while &#33;&#40;solved || tired&#41;</code></pre>
<p>Both <code>tired</code> and <code>solved</code> are Boolean indicators, that is, they are true to indicate that a certain situation has happened.</p>
<p>The variable <code>tired</code> is true if the elapsed time surpass the maximum time or if the number of iterations surpass the maximum of iterations. We also allow for the case of &quot;turning off&quot; the check by setting the corresponding maximum to 0 or a negative number.</p>
<p>The variable <code>solved</code> is true if the the point satisfies the first order condition.</p>
<p>The conditional at the end verifies these conditions and set the appropriate <code>status</code>.   Notice that we set the <code>status</code> to <code>:unknown</code> at the beginning, both for the good practice of having a default value, but also because if the code returns the <code>:unknown</code> status, we <strong>really</strong> don&#39;t know what happened.</p>
<h2 id=benchmarking ><a href="#benchmarking" class=header-anchor >Benchmarking</a></h2>
<p>With a solver in hands, we can start to do more advanced things, such as benchmarking and comparing our <code>newton</code> method to other solvers.</p>
<p>Since we only implemented one solved, we&#39;ll use <code>lbfgs</code> from the package JSOSolvers to compare against.</p>
<pre><code class=language-julia >using JSOSolvers

output &#61; lbfgs&#40;nlp&#41;
print&#40;output&#41;</code></pre><pre><code class="plaintext code-output">Generic Execution stats
  status: first-order stationary
  objective value: 2.239721910559509e-18
  primal feasibility: 0.0
  dual feasibility: 4.018046284781729e-9
  solution: [0.9999999986742657  0.9999999970013461]
  iterations: 18
  elapsed time: 0.0005769729614257812
</code></pre>
<p>And to compare both solvers, we need a collection of problems. Let&#39;s just create one manually for now.</p>
<pre><code class=language-julia >problems &#61; &#91;
  ADNLPModel&#40;x -&gt; x&#91;1&#93;^2 &#43; 4 * x&#91;2&#93;^2, ones&#40;2&#41;&#41;,
  ADNLPModel&#40;x -&gt; &#40;1 - x&#91;1&#93;&#41;^2 &#43; 100 * &#40;x&#91;2&#93; - x&#91;1&#93;^2&#41;^2, &#91;-1.2; 1.0&#93;&#41;,
  ADNLPModel&#40;x -&gt; x&#91;1&#93;^2 &#43; x&#91;2&#93; - 11 &#43; &#40;x&#91;1&#93; &#43; x&#91;2&#93;^2 - 7&#41;^2, &#91;-1.0; 1.0&#93;&#41;,
  ADNLPModel&#40;x -&gt; log&#40;exp&#40;-x&#91;1&#93; - 2x&#91;2&#93;&#41; &#43; exp&#40;x&#91;1&#93; &#43; 2&#41; &#43; exp&#40;2x&#91;2&#93; - 1&#41;&#41;, zeros&#40;2&#41;&#41;
&#93;;</code></pre>
<p>And now, we use <code>bmark_solvers</code> from the package SolverBenchmark to automatically run both solvers on all these problems.</p>
<pre><code class=language-julia >using SolverBenchmark

solvers &#61; Dict&#40;:newton &#61;&gt; newton, :lbfgs &#61;&gt; lbfgs&#41;
stats &#61; bmark_solvers&#40;solvers, problems&#41;</code></pre><pre><code class="plaintext code-output">Dict{Symbol, DataFrames.DataFrame} with 2 entries:
  :newton => 4×31 DataFrame
 Row │ id     name     nvar   ncon   nequ   status       objective     elapsed_time  iter   dual_feas  primal_feas  neval_obj  neval_grad  neval_cons  neval_jcon  neval_jgrad  neval_jac  neval_jprod  neval_jtprod  neval_hess  neval_hprod  neval_jhess  neval_jhprod  neval_residual  neval_jac_residual  neval_jprod_residual  neval_jtprod_residual  neval_hess_residual  neval_jhess_residual  neval_hprod_residual  extrainfo
     │ Int64  String   Int64  Int64  Int64  Symbol       Float64       Float64       Int64  Float64    Float64      Int64      Int64       Int64       Int64       Int64        Int64      Int64        Int64         Int64       Int64        Int64        Int64         Int64           Int64               Int64                 Int64                  Int64                Int64                 Int64                 String
─────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
   1 │     1  Generic      2      0      0  first_order   2.46519e-31      0.542545      1        Inf          0.0          3           4           0           0            0          0            0             0           1            0            0             0               0                   0                     0                      0                    0                     0                     0
   2 │     2  Generic      2      0      0  first_order   3.74398e-21      0.56531      21        Inf          0.0         50          64           0           0            0          0            0             0          21            0            0             0               0                   0                     0                      0                    0                     0                     0
   3 │     3  Generic      2      0      0  max_iter     -8.36356          0.492619    100        Inf          0.0        201         301           0           0            0          0            0             0         100            0            0             0               0                   0                     0                      0                    0                     0                     0
   4 │     4  Generic      2      0      0  first_order   1.43195          0.581732      5        Inf          0.0         12          16           0           0            0          0            0             0           5            0            0             0               0                   0                     0                      0                    0                     0                     0
  :lbfgs => 4×31 DataFrame
 Row │ id     name     nvar   ncon   nequ   status       objective     elapsed_time  iter   dual_feas   primal_feas  neval_obj  neval_grad  neval_cons  neval_jcon  neval_jgrad  neval_jac  neval_jprod  neval_jtprod  neval_hess  neval_hprod  neval_jhess  neval_jhprod  neval_residual  neval_jac_residual  neval_jprod_residual  neval_jtprod_residual  neval_hess_residual  neval_jhess_residual  neval_hprod_residual  extrainfo
     │ Int64  String   Int64  Int64  Int64  Symbol       Float64       Float64       Int64  Float64     Float64      Int64      Int64       Int64       Int64       Int64        Int64      Int64        Int64         Int64       Int64        Int64        Int64         Int64           Int64               Int64                 Int64                  Int64                Int64                 Int64                 String
─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
   1 │     1  Generic      2      0      0  first_order   2.26824e-16    4.81606e-5      8  5.28297e-8          0.0         11          10           0           0            0          0            0             0           0            0            0             0               0                   0                     0                      0                    0                     0                     0
   2 │     2  Generic      2      0      0  first_order   1.44561e-17    8.2016e-5      39  8.41132e-8          0.0         52          45           0           0            0          0            0             0           0            0            0             0               0                   0                     0                      0                    0                     0                     0
   3 │     3  Generic      2      0      0  first_order  -8.37235        3.60012e-5     12  1.60958e-9          0.0         17          15           0           0            0          0            0             0           0            0            0             0               0                   0                     0                      0                    0                     0                     0
   4 │     4  Generic      2      0      0  first_order   1.43195        2.59876e-5      9  4.18646e-9          0.0         11          11           0           0            0          0            0             0           0            0            0             0               0                   0                     0                      0                    0                     0                     0</code></pre>
<p>The results is a Dictionary of Symbols to DataFrame tables.</p>
<pre><code class=language-julia >@show typeof&#40;stats&#41;
@show keys&#40;stats&#41;</code></pre><pre><code class="plaintext code-output">typeof(stats) = Dict{Symbol, DataFrames.DataFrame}
keys(stats) = [:newton, :lbfgs]
</code></pre>
<p>Using SolverBenchmark, it&#39;s easy to create a markdown table from the results.</p>
<pre><code class=language-julia >cols &#61; &#91;:name, :status, :objective, :elapsed_time, :iter&#93;
pretty_stats&#40;stats&#91;:newton&#93;&#91;&#33;, cols&#93;&#41;</code></pre><pre><code class="plaintext code-output">┌─────────┬─────────────┬───────────┬──────────────┬────────┐
│    name │      status │ objective │ elapsed_time │   iter │
├─────────┼─────────────┼───────────┼──────────────┼────────┤
│ Generic │ first_order │  2.47e-31 │     5.43e-01 │      1 │
│ Generic │ first_order │  3.74e-21 │     5.65e-01 │     21 │
│ Generic │    max_iter │ -8.36e+00 │     4.93e-01 │    100 │
│ Generic │ first_order │  1.43e+00 │     5.82e-01 │      5 │
└─────────┴─────────────┴───────────┴──────────────┴────────┘
</code></pre>
<p>We can also create a similar table in .tex format, using something like</p>
<pre><code class=language-julia >open&#40;&quot;newton.tex&quot;, &quot;w&quot;&#41; do io
  pretty_latex_stats&#40;io, stats&#91;:newton&#93;&#91;&#33;, cols&#93;&#41;
end</code></pre>
<p>That will give us a nicely formatted table that we can just plug into our latex code.</p>
<h2 id=performance_profiles ><a href="#performance_profiles" class=header-anchor >Performance profiles</a></h2>
<p>Lastly, for comparison of the methods, it is costumary to show a Performance Profile.<sup id="fnref:2"><a href="#fndef:2" class=fnref >[2]</a></sup> Internally we use the package BenchmarkProfiles, though using <code>performance_profile</code> from SolverBenchmark will actually work directly with the output of <code>bmark_solvers</code>.</p>
<pre><code class=language-julia >using Plots
performance_profile&#40;stats, df -&gt; df.elapsed_time&#41;</code></pre>
<img src="/previews/PR25/assets/pages/tutorials/creating-a-jso-compliant-solver/code/output/perfprof.png" alt="Performance profile">
<p>Notice how the profile indicate that all problems were solved by <code>newton</code>, although it is clearly not the case. That happens because our cost function for the performance profile was only the elapsed time. A better approach would be something like.</p>
<pre><code class=language-julia >cost&#40;df&#41; &#61; &#40;df.status .&#33;&#61; :first_order&#41; * Inf &#43; df.elapsed_time
performance_profile&#40;stats, cost&#41;</code></pre>
<img src="/previews/PR25/assets/pages/tutorials/creating-a-jso-compliant-solver/code/output/perfprof2.png" alt="Performance profile">
<h2 id=improving_the_solver_more ><a href="#improving_the_solver_more" class=header-anchor >Improving the solver more</a></h2>
<p>Although we did implement the proposed method, we could improve the code a little bit. The following function is an improvement of the code in a few points:</p>
<ul>
<li><p>Reuse <code>obj&#40;nlp, x&#41;</code> and <code>grad&#40;nlp, x&#41;</code> when possible.</p>

<li><p>Stopping tolerances <code>atol</code> and <code>rtol</code> are used for a stopping criteria </p>

</ul>
\[ \|\nabla f(x_k)\| \leq \epsilon_{\text{absolute}} + \epsilon_{\text{relative}}\| \nabla f(x_0)\| \]
<ul>
<li><p>After computing the direction, we reduce <code>ρ</code> to try to speed up the method.</p>

</ul>
<pre><code class=language-julia >function newton2&#40;
  nlp :: AbstractNLPModel; # Only mandatory argument
  x :: AbstractVector &#61; copy&#40;nlp.meta.x0&#41;, # optimal starting point
  atol :: Real &#61; 1e-6, # absolute tolerance
  rtol :: Real &#61; 1e-6, # relative tolerance
  max_time :: Float64 &#61; 30.0, # maximum allowed time
  max_iter :: Int &#61; 100 # maximum allowed iterations
&#41;

  # Initialization
  fx &#61; obj&#40;nlp, x&#41;
  ∇fx &#61; grad&#40;nlp, x&#41;

  iter &#61; 0
  Δt &#61; 0.0
  t₀ &#61; time&#40;&#41;
  α &#61; 1e-2
  ρ &#61; 0.0
  status &#61; :unknown
  ϵ &#61; atol &#43; rtol * norm&#40;∇fx&#41;

  tired &#61; Δt ≥ max_time &gt; 0 || iter ≥ max_iter &gt; 0
  optimal &#61; norm&#40;∇fx&#41; &lt; ϵ

  while &#33;&#40;optimal || tired&#41; # while not optimal or tired

    B &#61; Symmetric&#40;hess&#40;nlp, x&#41;, :L&#41;
    factor &#61; cholesky&#40;B &#43; ρ * I, check&#61;false&#41;
    while &#33;issuccess&#40;factor&#41;
      ρ &#61; max&#40;1e-8, 10ρ&#41;
      factor &#61; cholesky&#40;B &#43; ρ * I, check&#61;false&#41;
    end
    d &#61; factor \ -grad&#40;nlp, x&#41;
    ρ &#61; ρ / 10

    t &#61; 1.0
    ft &#61; obj&#40;nlp, x &#43; t * d&#41;
    slope &#61; dot&#40;grad&#40;nlp, x&#41;, d&#41;
    while &#33;&#40;ft ≤ fx &#43; α * t * slope&#41;
      t *&#61; 0.5
      ft &#61; obj&#40;nlp, x &#43; t * d&#41;
    end
    t

    x &#43;&#61; t * d

    fx &#61; obj&#40;nlp, x&#41;
    ∇fx &#61; grad&#40;nlp, x&#41;

    iter &#43;&#61; 1
    Δt &#61; time&#40;&#41; - t₀
    tired &#61; Δt ≥ max_time &gt; 0 || iter ≥ max_iter &gt; 0
    ϵ &#61; atol &#43; rtol * norm&#40;∇fx&#41;
    optimal &#61; norm&#40;∇fx&#41; &lt; ϵ
  end

  if optimal
    status &#61; :first_order
  elseif tired
    if iter ≥ max_iter &gt; 0
      status &#61; :max_iter
    elseif Δt ≥ max_time &gt; 0
      status &#61; :max_time
    end
  end

  return GenericExecutionStats&#40;status, nlp, solution&#61;x, objective&#61;fx, dual_feas&#61;norm&#40;∇fx&#41;, iter&#61;iter, elapsed_time&#61;Δt&#41;

end</code></pre><pre><code class="plaintext code-output">newton2 (generic function with 1 method)</code></pre>
<p>And now testing again.</p>
<pre><code class=language-julia >solvers &#61; Dict&#40;:newton &#61;&gt; newton2, :lbfgs &#61;&gt; lbfgs&#41;
stats &#61; bmark_solvers&#40;solvers, problems&#41;
cost&#40;df&#41; &#61; &#40;df.status .&#33;&#61; :first_order&#41; * Inf &#43; df.elapsed_time
performance_profile&#40;stats, cost&#41;</code></pre>
<img src="/previews/PR25/assets/pages/tutorials/creating-a-jso-compliant-solver/code/output/perfprof3.png" alt="Performance profile">
<p><table class=fndef  id="fndef:1">
    <tr>
        <td class=fndef-backref ><a href="#fnref:1">[1]</a>
        <td class=fndef-content >Technically, it can be defined more generally, but the choice we made has better behaved values. <a href="https://en.wikipedia.org/wiki/Rosenbrock_function#:~:text&#61;In&#37;20mathematical&#37;20optimization&#37;2C&#37;20the&#37;20Rosenbrock,valley&#37;20or&#37;20Rosenbrock&#37;27s&#37;20banana&#37;20function">Wikipedia page: Rosenbrock page, access on 2021/Mar/17.</a>
    
</table>
 <table class=fndef  id="fndef:2">
    <tr>
        <td class=fndef-backref ><a href="#fnref:2">[2]</a>
        <td class=fndef-content >Dolan, E., Moré, J. Benchmarking optimization software with performance profiles. Math. Program. 91, 201–213 &#40;2002&#41;. <a href="https://doi.org/10.1007/s101070100263">doi.org/10.1007/s101070100263</a>
    
</table>
</p>

<div class=page-foot >
  <div class=copyright >
    &copy; Abel Soares Siqueira. Last modified: December 04, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div>  
    
        <script src="/previews/PR25/libs/katex/katex.min.js"></script>
<script src="/previews/PR25/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
        
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>